# 2022-QuickSort-Implementation
The proposed problem was to perform an analysis of the number of occurrences of the words used in a text based on a new lexicographic order.

# Trabalho Pr√°tico 2

```
DCC214 - Estrutura de Dados
Igor Joaquim da Silva Costa
```
## 1. Introdu√ß√£o

Oproblemapropostofoirealizarumaan√°lisedon√∫merodeocorr√™nciasdaspalavras
usadas em um texto baseada em uma nova ordem lexicogr√°fica.
Para resolver o problema citado, foramusados dois algoritmos de ordena√ß√£o,o
primeiro sendooQuicksortcommedianadeMelementoseosegundosendoaordena√ß√£o
InsertionSort para textos pequenos, sempre considerando a nova ordem lexicogr√°fica
requerida. Al√©mdisso,o programa√©capazdecorrigireventuaisproblemasnoarquivode
entrada,realizandoaconvers√£odecaracteresacentuadosparaseurespectivopar,semacentos,
a uni√£o de palavras com h√≠fen separadas por espa√ßos em branco e a remo√ß√£o de pontua√ß√£o.
Diantedoexposto,adocumenta√ß√£opresentepossuicomoobjetivodetalharcomoo
sistemafoiimplementado(Se√ß√£o2),oqu√£oeficienteelepodeseremtermoste√≥ricos(Se√ß√£o
3) e aplicados (Se√ß√£o 5), al√©m de explicar como o programa lida com poss√≠veis
inconsist√™nciasdurantesuaexecu√ß√£o(Se√ß√£o4).Porfim,oprojeto√©sumarizadojuntocomos
aprendizados gerados durante a produ√ß√£o do trabalho(Se√ß√£o 6).

## 2. M√©todo

Estase√ß√£otemcomoobjetivodiscutirasdecis√µesquelevaram√†atualimplementa√ß√£o
do programa.

# 2.1 Fluxo principal

Antesdedetalharcomooprogramaoperasobreumtexto,valediscorrerdemaneira
textual e intuitiva o que oprogramafaza cadapassodeexecu√ß√£o.Primeiramente,cada
palavra presente no texto √© lida e ‚Äú **normalizada** ‚Äù, ou seja,todo caracteremai√∫sculo ou
acentuado√©substitu√≠doporseurespectivoparecadapontua√ß√£opresente√©retirada.Munidos
da nova ordemlexicogr√°fica,oconjuntode palavras√© **ordenado** , deformaque palavras
repetidas ficam adjacentes e h√° a possibilidade de escolher quantos elementos ser√£o


considerados na mediana. Ap√≥s isso, √© feita a **contagem** de quantasvezescada palavra
apareceu no texto, que fica salva em um arquivo.

# 2.2 Armazenamento

Afimdesuportarasopera√ß√µesdescritasacima,√©necess√°rioumaestruturarobustao
suficienteparaguardarumsuperconjuntodepalavraseserposs√≠veldeencontrarqualquer
elemento de maneira r√°pida. Nesse sentido,a estrutura maispr√°tica se mostrou ovetor
din√¢mico,vistoqueomesmopossuitodasascaracter√≠sticasnecess√°rias,al√©mdepodervariar

seutamanho durantea execu√ß√£o.Otamanhoinicialdovetor√©de 105 elementos,n√∫mero
grande escolhidoparan√£oatrapalhar aexecu√ß√£ode testesdeperformance,visto ques√£o

necess√°riasao menos 105 palavrasemumtextoparaqueoprogramagastenom√≠nimo 60
segundos.Semprequeo tamanhodo textoformaiorque otamanhoatualdoarray,ele√©

realocado com o dobro de elementosat√© chegar no limite de 106 palavras, medida de
seguran√ßa para evitar overflow.

# 2.3 Normaliza√ß√£o da Palavra

Como as palavras da sa√≠daprecisam seguirumaformata√ß√£oespec√≠fica, setornou
v√°lidaapresen√ßadeumafun√ß√£oque‚Äúnormalize‚Äùaspalavraspresentes.Anormaliza√ß√£ose
tratadeumprocessoqueretiraqualquerpontua√ß√£oaomeiodapalavra,al√©mdetransformar
todasasletrasmai√∫sculasemmin√∫sculas.Paraeliminarapontua√ß√£o,aformamaisc√¥moda
encontradafoiarmazenaroscaracteresproibidosemumastringeapartirdelafazerbuscasna
palavra,seoi-√©simoelementodapalavraestiverentreoscaracteresdepontua√ß√£o,elen√£o√©
adicionado a nova string normalizada.

# 2.3 Normaliza√ß√£o da Palavra [EXTRA]

Para tratareventuais problemasnoarquivodeentrada,afun√ß√£odenormaliza√ß√£o√©
capazderetirarosacentosdal√≠nguaportuguesapresentesnapalavra.Essaopera√ß√£opodeser
confusa ao usar o tipo string padr√£o de C++, isso porque caracteres especiais n√£o s√£o
representadosdamesmaformaqueoscaracteresnormais.Comoumastring√©umalistade
palavras,nemtodosos 8 bitspresentesnotipochars√£ousadosparacodificarseuconte√∫do,
seusbitsiniciaiss√£ousadosparacodificarqualopr√≥ximocharpresentenapalavra,fazendo


comque umtipocharpadr√£odeC++s√≥possaarmazenarvaloresentre 0 e 127 databela
ASCII, o que √© um problema, j√° que todo caractere especial possui um valor maior que 127.
Dessaforma,umcaractereespecial√©formadodenom√≠nimo 2 posi√ß√µesdemem√≥ria
dotipochar, dificultandosuaopera√ß√£odiretausandoopera√ß√µesdestrings.Aformausada
pararesolveroproblemafoiusarumtipoalternativodestringfeitaespecialmenteparalidar
comesses‚Äúwidechars‚Äù.ConvertendoastringdoC++emumvetordecharpadr√£o,√©poss√≠vel
contarquantasposi√ß√µesdemem√≥riacadacaracteredastringocupaeusaressainforma√ß√£o
parafazerumcastdestringparawstring,umtipoondecompara√ß√µescomcaracteresespeciais
s√£o implementadas e funcionam da formacomque deveriam.Paraessefluxo funcionar,
usa-seabibliotecalocaleparafor√ßarqueoscaracteresadvindosdaentradaestejamnopadr√£o
UTF-8.

# 2.4 Ordena√ß√£o QuickSort

Como especificadonaementado trabalho,a ordena√ß√£o√© feitaa partirdom√©todo
QuickSort, que√© umalgoritmode ordena√ß√£oque usadividireconquistarpararesolvero
problemadaordena√ß√£o.ApremissadoQuickSort√©,apartirdeumpiv√¥, dividiroconjunto
em 2 subparti√ß√µesmenores,umacomelementosmenoresqueopiv√¥eoutracomelementos
maioresqueopiv√¥,fazendoissosucessivamenteparaassubparti√ß√µestemcomoresultadoum
vetor ordenado. Entretanto, existem formas de tornar esse algoritmo mais eficiente,
principalmenteaoescolhermoscomcautelaqualelementoser√°opiv√¥eaoordenarparti√ß√µes
pequenas usando outros algoritmos maissimples que o QuickSort. Dessaforma, ambos
comportamentos foram implementados na fun√ß√£o.

# 2.5 InsertionSort

Paraordenarasparti√ß√µesmenoreseencontraramedianadeumaparti√ß√£o,foiutilizado
o algoritmo deordena√ß√£o InsetionSort.Aideiaportr√°s dele√© queo maiorelementodo
conjuntosempreestar√°na√∫ltimaposi√ß√£o,dessaforma,bastairgradualmentecomparandoo
primeiroelementodovetorcomtodososoutros,at√©chegarnofinal,seoelementocomparado
formenorouigualcomesseprimeiroelemento,elestrocamdelugar,aofinaldaexecu√ß√£o,
todo elemento est√° na sua devida posi√ß√£o.
Sendoassim,oInsertionSort√©√∫tilparalidarcomparti√ß√µesj√°ordenadas,vistoqueos
elementosj√°est√£oemposi√ß√£oenuncaocorreramtrocas.Dessaforma,elefoiescolhidopara
ordenarasparti√ß√µesmenores,j√°queelaspossuemumamaiorchancedej√°estaremordenadas.


Damesmamaneira,elefoiescolhidoparaencontraramedianadaparti√ß√£o.Seaparti√ß√£otiver
menoselementosqueonecess√°rioparacalcularamediana,√©feitaamedianade 2 elementos,
seaparti√ß√£otivermenosque 2 elementoselanuncachamar√°afun√ß√£omediana,devidoao
caso base do QuickSort.

# 2.6 Compara√ß√£o de palavras

Aprincipalopera√ß√£odaordena√ß√£o√©decidirseumapalavra√©menorqueoutra,no
casodanovaordemlexicogr√°ficapresentenoproblema,setornav√°lidaaexist√™nciadeuma
fun√ß√£obooleanaqueretornaseduaspalavrass√£omenoresouiguais.Paraisso,foicriadoum
vetorde 26 inteirosquerepresentaanovaordemlexicogr√°ficadecadaumadas 26 letrasdo
alfabeto.Afimdecompararduaspalavras,bastaprocurarpelaposi√ß√£odoprimeirocaractere
destoanteentreelaseretornarseaquelecaracterenaposi√ß√£oencontrada√©menorouigualao
caracterenastringdecompara√ß√£o.Seessaposi√ß√£on√£oexistir,bastacompararotamanhodas
strings,seelastiveremomesmotamanho,elass√£oamesmastring,sen√£o,amenor√©aquela
com o menor tamanho.

# 2.7 Contagem de palavras

Comaspalavrasj√°ordenadasnovetordepalavras,acontagemdepalavrasrepetidas
setornatrivial,vistoquetodapalavrarepetidaficar√°adjacentedentrodovetor.Sendoassim,
bastaacria√ß√£odelistaauxiliaresparaarmazenaraspalavrasequantasvezeselasaparecem,
lendo linearmente a lista de palavras.

## 3. An√°lise de complexidade

# 3.1 Espa√ßo

```
Inicialmente,√©criadoumvetordepalavrasdetamanho 105 ,sendoassim,paratextos
```
commenosque 105 palavras,oespa√ßogasto√©constante.Entretanto,seotextotivermais
palavras que esse limite, mais mem√≥ria √© alocada e a complexidade se tornaùëÇ(ùëÅ) na
quantidade de palavras.


# 3.2 Tempo

```
Para an√°lise de tempo, considere N o n√∫mero de palavras do texto.
```
## 3.2 Ordena√ß√£o

Paraserealizaraordena√ß√£o,s√£outilizadosdoisalgoritmosemconjunto,oQuickSort
paralidarcomparti√ß√µesmuitograndeseoInsertionSortparaordenarparti√ß√µesmenorese
encontrar medianas. Considerando a compara√ß√£o como opera√ß√£o mais significativa, √©
conhecidoqueoQuickSortefetuaùëÇ(ùëÅ*ùëôùëúùëî(ùëÅ))compara√ß√µesemvetoresdesordenadosem
m√©dia, j√°queacadachamadadom√©todotodososelementoss√£ocomparadoumavezes√£o
realizadoscercadeùëôùëúùëî(ùëÅ)chamadas.Entretanto,esseargumento√©v√°lidoapenasnoscasos
queaescolhadopiv√¥fazcomqueoconjuntosejadivididoem 2 partesdetamanhopr√≥ximo,
seporacasoopiv√¥foromenorouomaiorelementodoconjunto,todososdemaiselementos
ficamdentrodentrodamesmasub-parti√ß√£oeaexecu√ß√£odepasson√£otrazmuitasmelhoras
na ordena√ß√£o do conjunto. Essa propriedade √© especialmente prejudicial em vetoresj√°
ordenadosemordemcrescenteoudecrescente,transformandoon√∫merodepassosdeùëôùëúùëî(ùëÅ)

para N, gerando uma complexidade deùëÇ(ùëÅ^2 )nessescasos, que s√£o os piores.
Outrossim, existem formas de evitar com que essescasos aconte√ßam.Aprimeira
maneira√© utilizaroalgoritmodeInsertionSortemparti√ß√µespequenas.Talm√©todoajudaa
mitigar o problema pois parti√ß√µes pequenas t√™m mais chancesdeestarem ordenadasem
rela√ß√£oa parti√ß√µesgrandes. Nessesentido,setornav√°lidaaan√°lisedoqu√£oeficaz√©essa
medida:

3.2.1 InsertionSort Para parti√ß√µes menores

Para entender como o InsertionSortpode ser ben√©fico se usado em conjunto ao
QuickSort,primeiros√£onecess√°riasalgumasan√°lisesepremissas.OInsertionSort√©ùëÇ(ùëÅ) em
vetoresordenadosdeformacrescente,j√°queoelementousadoparaacompara√ß√£o√©sempre
menorqueoresto,nuncaacontecendocompara√ß√µesadicionaisparamudaroselementosde

lugar. Nos piores casos e nos casos m√©dios,ele √© ùëÇ(ùëÅ^2 ),j√°que cadaelementovaiser
comparadocomtodososoutrostodasasvezes,emm√©dia.Al√©mdisso,podemosconsiderar
que as entradas sempre ser√° uma pot√™ncia de 2, para facilitar a an√°lise.


```
SendoSotamanhom√≠nimonecess√°rioparaumaparti√ß√£oserconsideradapequena,
```
podemosanalisarqualoefeitoqueoInsertionSortter√°emumQuickSortcomentradaN= 2 ùëò
da seguinte maneira:

ComoN√©umapot√™nciade2,a√°rvoredechamadasdom√©todoQuickSortcorresponde
auma√°rvorebin√°riacompletadealturaKcom2N+ 1 n√≥s,representandoototaldechamadas
recursivasfeitas,onde acada passootamanhodasub-parti√ß√£ocorrespondea 2 elevado√†
alturadon√≥.Entretanto,cadasubparti√ß√£ocomtamanhomenorouigualaSdevesertratada
como InsertionSort.

Encontrarquaisn√≥spossuemessapropriedade√©f√°cil,seS= 2 ùë†,todososn√≥scom
alturamaiorque‚Äús‚Äùv√£osertratadospeloQuickSort,logo,oQuickSortvaiserexecutadonos
n√≠veisentre 0 e(K-s),ouseja,entre 0 eùëôùëúùëî(ùëÅ/ùëÜ).Emrela√ß√£oaoInsertionSort,eleser√°

chamado apenasnon√≠vel‚Äús‚Äù, quepossui 2 ùêæ^ ‚àí^ ùë†^ n√≥s,detamanho 2 ùêøcada.Sendoassim,a
fun√ß√£o de complexidade apenas do InsertionSort para parti√ß√µes pequenas √©

```
ùëî(ùëÅ= 2 ùëò) = 2 ùêæ^ ‚àí^ ùë†*( 2 ùë†)^2 = 2 ùêæ^ +ùë† = ùëÅ*ùëÜ
```
Da mesma maneira a fun√ß√£o de complexidade do QuickSort fica:
‚Ñé(ùëÅ) =ùëÅ*(ùêæ ‚àí ùë†)=ùëÅ*ùëôùëúùëî(ùëÅ/ùëÜ)

Sendo assim, a complexidade da ordena√ß√£o no caso m√©dio f(N) = g(N) + h(N) se torna:
ùëì(ùëÅ) = ùëÅ*ùëôùëúùëî(ùëÅ/ùëÜ) + ùëÅ*ùëÜ


Tomar S = N corresponde a executar o InsertionSort em todo conjunto, fazendo com que a
complexidade se torne quadr√°tica. Se S for um valor pequeno em rela√ß√£o a N, a ordem de
complexidade se torna a mesma do QuickSort normal:

```
ùëì(ùëÅ) = ùëÅ*ùëôùëúùëî(ùëÅ/ùëÇ( 1 ) ) + ùëÅ*ùëÇ( 1 ) = ùëÇ( ùëÅ*ùëôùëúùëî(ùëÅ))
```
De maneira an√°loga, se a entrada for um conjunto ordenado de maneira crescente, cada
chamada do QuickSort diminui o tamanho da parti√ß√£o em 1, at√© que o tamanho do conjunto
seja S:

## X = N - S;

## ùëì(ùëÅ) =

```
ùëñ = 1
```
```
ùëã
```
## ‚àë(ùëÅ ‚àí ùëñ) + ùëÜ

## ùëì(ùëÅ) = ùëã*(ùëÅ‚àíùëã 2 +^ ùëÅ^ ‚àí^1 ) + ùëÜ = (ùëÅ‚àíùëÜ)*(ùëÅ 2 +^ ùëÜ^ ‚àí^1 ) + ùëÜ

## ùëì(ùëÅ) = (ùëÅ ‚àí ùëÜ)¬≤ + ùëÜ

Omesmoacontececomconjuntosordenadosdeformadecrescente,ouseja,seoNfor
pequenoosuficienteparaestarpr√≥ximodeS-ouoSgrandeosuficienteparaserpr√≥ximode
N-omelhorcaso setornalineareocasom√©dioficaquadr√°tico,n√£ohavendograndeganho
assint√≥ticoentreessem√©todoeoInsertionSortpadr√£o.Entretanto,talsitua√ß√£os√≥acontece,
porqueoalgoritmoaindaapresentaproblemasnahoradelidarcomconjuntosj√°ordenados,
sendo v√°lida a estrat√©gia da mediana de M elementos:

3.2.2 InsertionSort para mediana de M elementos

Entende-secomomedianadeumconjuntocomoovalorcentralpresentenele,sabendo
a medianadeconjuntodesordenado,√© f√°cilsepar√°-lo em 2 subconjuntosdecomquasea
mesmaquantidadede elementos,tomandooselementosmenoresquea medianaparaum
conjuntoeosmaiores,paraoutro.NocontextodoQuickSort,opiv√¥semprecorresponder√†
medianadesuaparti√ß√£oconfiguraumaescolha√≥tima,j√°queaparti√ß√£ovaiserseparadaem


duasoutras subparti√ß√µesque tamb√©mser√£odivididassucessivamente,numtotaldelog(N)
vezes. Dessa forma, escolher a mediana como piv√¥ garante que o QuickSort seja
ùëÇ( ùëÅùëôùëúùëî(ùëÅ))em qualquer caso. Entretanto, encontrara mediana tamb√©m possui um custo.
Como amediana√© ovalorcentraldaparti√ß√£o,aformamaisf√°cildeencontr√°-la√©
ordenaraparti√ß√£oeescolheroelementonaposi√ß√£oùëÅ/2,s√≥queparaordenaraparti√ß√£o√©o
problema queestamostentando resolver.Umaoutraalternativa√©n√£opegaramedianada
parti√ß√£ointeira,esim escolheramedianadosprimeirosMvalorespresentescomopiv√¥e
trabalhar com ela, garantindo um aumento na efici√™ncia geral do algoritmo.
Aindaassim,essaop√ß√£otamb√©mpossuiumcusto,quepodeserestimadodamesma
formafeita nase√ß√£oanterior.Comodiscutidoanteriormente,ousodamedianafazcoma
fun√ß√£odecomplexidadedoalgoritmofiqueùëÅùëôùëúùëî(ùëÅ)+Xemqualquercaso,ondeX√©ocusto
adicionalparacalcularasmedianas.Demaneirasimilar,amedianadeMelementoss√≥ser√°

executadaenquantootamanhodaparti√ß√£oanalisadaformaiorouigualaM,seN= 2 ùêæeM=

2 ùëö,issocorresponde√†todososn√≥scomprofundidademenorqueùêæ ‚àí ùëö + 1 ,ouseja,

2 ùêæ‚àíùëö+^1 ‚àí 1 ou( 2 ùëÅùëÄ ‚àí 1 )n√≥s.

Para cada um desses n√≥s, √© feita uma ordena√ß√£o de M elementos usando o
InsertionSortparasedescobriramediana,essaopera√ß√£o√©quadr√°ticaemM,logo,sendod(N)
a fun√ß√£o para calcular as medianas de uma entrada de tamanho N:


##### ùëë(ùëÅ) =( 2 ùëÅùëÄ ‚àí 1 )*ùëÄ^2 = 2 ùëÅùëÄ ‚àí ùëÄ^2

Afun√ß√£odecomplexidadeparaM>2,quegarantequenuncaser√°escolhidooumenorouo
maior elemento da parti√ß√£o fica:

```
ùëì(ùëÅ) =ùëÅùëôùëúùëî(ùëÅ) + ùëë(ùëÅ) =ùëÅùëôùëúùëî(ùëÅ)+ 2 ùëÅùëÄ ‚àí ùëÄ^2
```
Se M for menor que ùëôùëúùëî(ùëÅ), a fun√ß√£o f(N) √© O(Nlog(N)) emtodos os casos,
garantindoumaexecu√ß√£opr√≥ximade√≥timaparaoalgoritmoindependentedotipodeentrada,
isto porqueasparti√ß√µesquen√£ousaremat√©cnicadamedianaser√£opequenaseordenadas
peloInsertionSort,comoditonase√ß√£o3.2.1.Al√©mdisso,acombina√ß√£odamedianadeM
elementose aordena√ß√£o simplesparaparti√ß√µes pequenasmelhoraaindamaisaconstante
envolvidanacomplexidadedoalgoritmo,vistoqueousodamedianaproporcionaumamaior
incid√™nciadesubparti√ß√µesj√°ordenadasdentreaschamadasrecursivasdoQuickSort,havendo
casos onde a fun√ß√£o de complexidade se torna

```
ùëì(ùëÅ,ùëÜ,ùëÄ) =ùëÅùëôùëúùëî(ùëÅùëÜ) +ùëÜ + 2 ùëÅùëÄ ‚àí ùëÄ^2 =ùëÇ(ùëÅùëôùëúùëî(ùëÅ))
```
se S e M forem suficientemente pequenos em compara√ß√£o a N.
Porfim,conclui-seque,adependerdasescolhasdeSeMemrela√ß√£oaN,realizar
mais opera√ß√µes em conjunto ao QuickSort apresenta melhoras em sua complexidade
assint√≥tica para alguns casos.

### 3.3 Busca

Considerandoacompara√ß√£ocomoaopera√ß√£omaissignificativa,quetodabuscapelas
palavrasaconteceap√≥s ovetorserordenadoe todapalavrarepetidaficaadjacenteap√≥sa
ordena√ß√£o,para-sebuscaraspalavrasrepetidas,s√≥√©necess√°riopercorrerovetorumavez,
checandoseoelementoatual√©igualaopr√≥ximo.Dessaforma,contaraquantidadedevezes
que cada palavra acontece no texto √©ùëÇ(ùëÅ).

### 3.4 Comparar Palavras.

Outroprocessoque√©significativonaan√°lisedecomplexidadedoprograma√©oqu√£o
bemelecompara seumapalavra√©menorqueoutra.Aestrat√©giausadasegueumal√≥gica
sequencial,varre-seamenorpalavra at√©encontrar oprimeirocaracterequesejadiferente
entreasduas,seessecaracterenaprimeirapalavraformenorouigual√†ordemlexicogr√°fica


do caractere na mesmaposi√ß√£oda segundapalavra, retornaverdadeiro. Sen√£oexistirem
caracteresdiferentes,amenorpalavra√©aquelaquepossuiomenortamanho.Dessaforma,a
compara√ß√£o √©ùëÇ(ùêø), onde L √© o tamanho m√©dio de umapalavra do texto.

## 3.5 Complexidade Geral.

Ditoisso,acomplexidadegeraldaordena√ß√£ocorrespondeaoprodutoentreocustode
comparar as palavras e a quantidade de compara√ß√µes feitas, ou seja:
ùëÇ(ùëÅùëôùëúùëî(ùëÅ)*ùêø)

## 4. Estrat√©gias de Robustez

Aolidarcomlistasdestrings,aquantidadedemem√≥riadispon√≠velparaoprograma
podefacilmenteserinsuficienteparasuaopera√ß√£o,dessaforma,s√£opermitidostextoscomno

m√°ximo 106 palavras.

## 5. An√°lise Experimental

Aan√°liseexperimentalaseguirtemcomoobjetivomediroqu√£oeficiente√©osistema
implementadousandoduasm√©tricas,odesempenhocomputacional-qu√£or√°pidooprograma
√© executado com entradas grandes - e an√°lises de acesso em mem√≥ria.

# 5.1 Desempenho computacional

## 5.1.1 Perfil de execu√ß√£o

Para testarodesempenhocomputacional,primeiramente,oprogramafoicompilado
em estadode "profiling",a fimde analisarquais fun√ß√µes consomemrelativamentemais
tempoduranteaexecu√ß√£odoprograma.Diantedisso,foramfeitasbateriasdetestesapartir

detextosretiradosdeEbooksgratuitos,ondecadalivropossuicercade 105 palavras.Como
profile das execu√ß√µes pronto, cada execu√ß√£o √© processada pelo programa ‚Äúgprof‚Äù,uma
ferramentaqueauxilianaan√°lisedodesempenhocomputacional.Ditoisso,segueaan√°lise
das chamadas de fun√ß√µes.


```
Tempo de
execu√ß√£o
(%)
```
```
Calls
```
```
46.24 49822106 isLessEqual(std::string,std::string)
16.18 81907 partition(std::string, int, int, int)
12.43 48317830 void std::swap<string,string>
10.40 _init
6.36 49822106 unsigned long const& std::min<unsigned long>
4.34 97118 normalize(string)
1.16 84939 insertionSort(std::string, int, int, int)
1.16 1 leitura_arquivo(std::basic_ifstream<char)
0.58 81907 mediana_simples(std::string, int, int, int)
0.58 1 start_order(int*)
```
Para evitar redund√¢ncia, os outros perfis de execu√ß√£o apresentam o mesmo
comportamento dotesteapresentadoacima.Noquetangeaan√°lisedosexperimentos,fica
evidentequeafun√ß√£oquemaisdemandatempo,emporcentagem,√©afun√ß√£oparacomparar
seumapalavra√©menorqueoutra,j√°queessa√©aopera√ß√£oprincipaldaordena√ß√£o.Al√©m
disso,afun√ß√£oapresentacomplexidadelinearnotamanhodaspalavrase√©chamadacercade
3 * ùëÅùëôùëúùëî(ùëÅ) vezesduranteoprograma,usando af√≥rmuladesenvolvida na se√ß√£o3.2.2.
Dessaforma,afun√ß√£ode compara√ß√£oestaremprimeirolugarn√£o √© degrandesurpresa,
embora existam formas de diminuir esse tempo de execu√ß√£o usando de t√©cnicascomo
hashing.
Afun√ß√£oqueocupaasegundaposi√ß√£o√©afun√ß√£oqueparticionaovetorduranteo
QuickSort.
Oterceirolugarsetratadafun√ß√£oquetrocadoiselementosdovetordeposi√ß√£o.Como
otextoutilizadonotestefoiretiradodeumlivro,existemmuitaspalavrasrepetidas,quefaz
comquemuitastrocasdeposi√ß√µesocorram,vistoqueaopera√ß√£onecess√°riaparaexecutar
umatroca√© aopera√ß√£o menorouigual.Nessesentido,utilizarumcomparadorapenasde
igualdade teria diminu√≠do o n√∫mero de trocas e deixaria o programa mais eficiente.
Afun√ß√£o_initqueocupaoquartolugarserveparacarregarecompartilharasfun√ß√µes
dediferentesarquivosduranteaexecu√ß√£odoprograma.Implementarafun√ß√£odecompara√ß√£o
no mesmo arquivo das fun√ß√µes de ordena√ß√£o resolveria o problema.
Porfim,a√∫ltimafun√ß√£ov√°lidaparasecomentar√©anormalize,querepresentou4%do
tempodeexecu√ß√£odoprograma.Esta√©afun√ß√£ousadapararetirarletrasmai√∫sculas,acentos


epontua√ß√µesdapalavraantesdelaserinserida.Paracadapalavranoarquivodeentrada,a
fun√ß√£onormalize√©chamada,fazendocomqueelatenhacomplexidadelinearnotamanhoda
entrada,sendojustoelasersignificativanotempodeexecu√ß√£oparaaordena√ß√£odetextos
com muitos acentos.
Nessesentido,conclui-sequeaindaexistemmargensparaamelhoranodesempenho
doprograma,an√≠veldechamadasdefun√ß√µes,vistoquemuitasdelaspoderiamserfeitasde
outras formas, a fim de melhor utilizar tempo de execu√ß√£o do programa.

### 5.1.2 Desempenho em termos da entrada

Al√©mdotempogasto pelaschamadasde fun√ß√µes, deve-semedirarela√ß√£oentreo
aumentodovolumedaentradadoprogramacomoseutempodeexecu√ß√£o.Pararealizartal
objetivo,foiutilizadaaferramentaMemlogdoprofessorWagnerMeiraeferramentasparaa
gera√ß√£o de gr√°ficos. A seguir, o gr√°fico com os resultados.

Como visto acima,o tempodeexecu√ß√£ocresce muitopr√≥ximoaonlog(n), assim
como foi discutido na se√ß√£o de an√°lise de complexidade.
Para confirmar que o programa n√£o performava de maneira quadr√°tica, foram
realizados testes usando apenas o InsertionSort para ordena√ß√£o:


```
Emboraosdoisgr√°ficossejamparecidos,oInsertionSortrecebeuentradasdaordem
```
de 104 para ficar com um tempo de execu√ß√£o similarao QuickSort com entradas de 105.

Ogr√°ficoacimamostraoqueaconteceaovariaraescolhadamedianaedotamanho
da parti√ß√£opequenacombasenotamanhodaentrada.Comumaan√°lisemaisdetalhada,√©
poss√≠velobservarqueaescolhadessespar√¢metrosn√£oafetamuitootempodeexecu√ß√£opara
textoscommenosquemeiomilh√£odepalavras,emboratextosgrandessebeneficiemdessa
t√©cnica. Para elucidar tal fato, foram feitas baterias de testes com o texto de 500.000 palavras:


A partir do gr√°fico, √© poss√≠vel notar escolher mediana de M elementos com M
desnecessariamente grande pode piorar o tempo de execu√ß√£o do programa, tal fato √© visto ao
avaliar que cada coluna colorida √© maior do que a coluna anterior, para qualquer tamanho de
parti√ß√£o. Al√©m disso, os menores tempos de execu√ß√£o ficaram nas escolhas de parti√ß√£o
pr√≥ximas a Nlog(N), que nesse caso √© 18.
Para al√©m disso, foram feitos testes com valores de mediana e de parti√ß√£o extremos, o
primeiro sendo S = 50 e M = 500, que executou em 605 segundos, ou 10 minutos, e o caso
S = 500.000 M = 1, que executou em 1717 segundos, ou 28 minutos, que representa o valor
ùëÅ¬≤para essa entrada. Por fim, vale ressaltar queo tempo de execu√ß√£o m√©dio para o QuickSort
nessa entrada foi 25 segundos.

# 5.2 An√°lise de localidade de refer√™ncia e acesso de mem√≥ria

Comoexplicadoemaula,programaseficientesemusodemem√≥rias√£oaquelesque
tendemaacessarregi√µesdemem√≥riacont√≠guas,j√°queessapr√°tica√©otimizadapelossistemas
operacionais onde o programa √© executado. Tal propriedade √©chamadade localidadede
refer√™ncia e √© uma √≥tima m√©trica de como o programa acessa a mem√≥ria por ele utilizada.
Nessesentido,munidodasferramentasAnalisamemeMemlog,disponibilizadaspelo
professorWagnerMeira,√©poss√≠velgerargr√°ficosquedemonstramoacessodemem√≥riado
programaemsuasdiversasfases,e,assim,analisarseoacessodemem√≥riadoprograma
segue as boas pr√°ticas desejadas. Dito isso, segue a an√°lise de acesso de mem√≥ria e
localidadederefer√™ncia,ondeoid 0 representaainser√ß√£odoselementosnovetor,oid 1 a
ordena√ß√£o das parti√ß√µes pequenas pelo InsertionSort e o id 2 como os acessos do QuickSort.



Comovistoacima,oprogramaacessadiversasvezesposi√ß√µesdemem√≥riaadjacentes,
issoaconteceporqueoselementosest√£odispostosportodoovetor.Dessaforma,√©esperado
queadist√¢nciadepilhasejaalta,vistoqueelementosdistantesnamem√≥rias√£oacessadose
trocados de posi√ß√£o durante toda a execu√ß√£o do programa.


Dessaforma,conclui-sequeosistemanemsempremant√©mumabaixadist√¢nciade
pilhadurante aexecu√ß√£o,desfavorecendo ahip√≥tesedo acessoemposi√ß√µes cont√≠guasde
mem√≥ria e sendo uma flocalidade de refer√™ncia.

### 6. Conclus√µes

Com ointuitode contarquantaspalavrasexistememumtexto,eapresent√°-lasem
umanova ordemlexicogr√°fica,foi implementadoumprograma queutilizaalgoritmosde
ordena√ß√£o de forma n√£o trivial para resolver o problema.


Duranteoprojetodosistemaforamlevadasemconsidera√ß√£on√£os√≥aspectospr√°ticos
doprocessamentodetexto,mastamb√©mcomoalinguagemdeprograma√ß√£oescolhidapoderia
serumaferramenta√∫til parachegarnoobjetivo esperado.Todaaquest√£ode mapearum
mini-mundo de interesse em um modelo computacional robusto se mostrou bastante
produtiva, levando o aluno a pensar em formas criativas de se resolver e entender o
problema,tendocomoresultadoumaextensadiscuss√£osobrecomoosm√©todosdamedianae
daordena√ß√£osimplesparaparti√ß√µespequenasafetamodesenvolvimentodoprograma.Por
fim,otempoextra usadoparaprojetarosistematrouxev√°riasrecompensasnosentidoda
implementa√ß√£o, sendo um aspecto a ser levado para trabalhos futuros.
Al√©m disso,os testese aan√°lise decomplexidade semostraram muito√∫teispara
entendercomoasentradasinfluenciamaexecu√ß√£odoprogramaecomoalgunsdetalhesde
implementa√ß√£o podem ser significativos em termos de desempenho computacional e
localidade de refer√™ncia.
Nessesentido,todoofluxodetrabalhofoiessencialparaaconsolida√ß√£odeconte√∫dos
aprendidos emsala, al√©m de apresentar,de formapr√°tica,comosoftwaresmaiores, mais
consistentes e robustos s√£o projetados e implementados.

### 7. Bibliografia:

Ziviani,N.(2006).ProjetosdeAlgoritmoscomImplementa√ß√µesemJavaeC++:Cap√≠tulo3:
Estruturas de Dados B√°sicas. Editora Cengage.

Paulo Feofiloff, Notas de Aula da disciplina Projeto de Algoritmos (2018). DCC-IME-USP.
dispon√≠vel em:https://www.ime.usp.br/~pf/algoritmos/aulas/


### 8. Instru√ß√µes para compila√ß√£o e execu√ß√£o:

### 8.1 Compila√ß√£o

Existempartesdoprogramaques√£ocompat√≠veisapenas√†svers√µesmaisrecentesda
linguagem c++, dito isso, deve-se seguir as seguintes configura√ß√µes para a compila√ß√£o:

```
Linguagem: C++
Compilador: Gnu g++
Flags de compila√ß√£o:-std=c++11 -g
Vers√£o da linguagem: standard C++1 1
Sistema operacional (prefer√™ncia): distribui√ß√µes baseadas no kernel Linux 5.15.
```
Ocomandoparacompilaroprogramaautomaticamenteest√°presentenoarquivo **‚ÄúMakefile‚Äù**
esuaexecu√ß√£o√©chamadapelocomando **‚Äúmakeall‚Äù** .Aindaassim,seguemasinstru√ß√µespara
compilar manualmente:

Parageraroexecut√°veldoprograma,√©necess√°rio,primeiro,geraroobjetoparacadaarquivo
presentenapasta‚Äú/src‚Äù.Talobjetivopodeseralcan√ßadoseguindoosseguintescomandosem
ordem:

```
g++ -g -std=c++11 -Wall -c src/main.cpp -o obj/main.o -I./include/
g++ -g -std=c++11 -Wall -c src/memlog.cpp -o obj/memlog.o -I./include/
g++ -g -std=c++11 -Wall -c src/ordenacao.cpp -o obj/ordenacao.o -I./include/
g++ -g -std=c++11 -Wall -c src/str_funcs.cpp -o obj/str_funcs.o -I./include/
```
Ap√≥sessepasso,deve-sejuntartodososobjetosemum√∫nicoarquivoexecut√°vel,seguindoo
comando:
g++ -g-std=c++11-Wall -o./bin/tp2.out ./obj/main.o ./obj/memlog.o ./obj/ordenacao.o
./obj/str_funcs.o

Deste modo, o execut√°vel ‚Äú/bin/tp2.out‚Äù estar√° compilado e pronto para ser utilizado.

#### 8.2 Execu√ß√£o

```
Seguem as instru√ß√µes para a execu√ß√£o manual:
```

1. Certifique-se que o compil√°vel foigeradode maneiracorreta,sealgum problema
    ocorrer, execute o comando ‚Äúmake all‚Äù presente no ‚ÄúMakefile‚Äù.
2. Dadoqueocompil√°velfoigeradodemaneiracorreta,certifique-sequeoarquivode
    entrada existe. Se ele n√£o existir, crie-o.
3. Certifique-sequeoarquivodeentradaest√°naformata√ß√£oesperada,ondeexisteum
    marcador#ORDEMparamarcaranovaordemlexicogr√°ficaeomarcador#TEXTO
    para marcar o texto a ser lido
4. Uma vez que os passos anteriores foram cumpridos, executeo programa com o
    comando: ./bin/tp2.out-i(entrada)-o(saida)-s(tamanhoparticao)-m(valorda
    mediana de m)
5. A sa√≠da estar√° guardada no arquivo de saida.



